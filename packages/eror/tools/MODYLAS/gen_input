#!/usr/bin/env python

import os
import os.path
import shutil
import sys
import re
import pickle
import math
from optparse import OptionParser

parser = OptionParser()

parser.add_option("-o", "--stdout", dest = "stdout",
                  help = "Stdout generated by MODYLAS")

parser.add_option("-t", "--traj", dest = "traj",
                  help = "Solution or reference trajectory file (dcd format)")

parser.add_option("-x", "--mdxyz", dest = "mdxyz",
                  help = "Initial coordinate file required when Fast Multipole Method is used (mdxyz format)")

parser.add_option("-r", "--rigid", dest = "rigid",
                  help = "Solute structure file (rigid solute) (pdb or mdxyz format)")

parser.add_option("-s", "--flexible", dest = "solute",
                  help = "Solute trajectory file (flexible solute) (dcd format)")

parser.add_option("-d", "--div", dest = "div", type = "int",
                  help = "Number of divided sections",
                  default = None)

parser.add_option("--minenergy", dest = "minenergy", type = "float",
                  help = "Minimum energy in kcal/mol",
                  default = -20.0)

parser.add_option("--maxins", dest = "maxins", type = "int",
                  help = "Number of insertions for refs (default: 1000)",
                  default = 1000)

parser.add_option("-v", "--verbose", dest = "verbose", action = "store_true",
                  help = "Increase verbosity (for debug)",
                  default = False)

(options, args) = parser.parse_args()

mode = "solution"

if options.rigid != None or options.solute != None:
    mode = "reference"

params = {}
try:
    ifh = file(".extraparam", "rt")
    carryover = pickle.load(ifh)
    ifh.close()

    if mode == "solution" and "sltpick" in carryover:
        params["sltspec"] = carryover["sltpick"]
    
except OSError:
    pass

def log(x):
    if options.verbose:
        print >> sys.stderr, x

def warn_or_error(x, col):
    prefix = ""
    suffix = ""
    if os.isatty(sys.stderr.fileno()):
        prefix = "\x1b[" + str(col) + ";1m"
        suffix = "\x1b[0m"
    print >> sys.stderr, prefix + x + suffix

def warn(x):
    warn_or_error("Warning: " + x, 33)

def error(x):
    warn_or_error("Error: " + x, 31)
    sys.exit(1)

def safe_close(fh):
    # asynchronous NFS may miss file creation
    # esp. combined with delayed allocation (ext4, XFS)
    fh.flush()
    os.fsync(fh.fileno())
    fh.close()

def check_exists(f):
    if not os.path.exists(f):
        error("file " + f + " does not exist")

def erfc(x):
    t = 1 / (1 + 0.5 * x)
    tau = t * math.exp(-x**2 - 1.26551223 + 1.00002368 * t + 0.37409196 * t**2 + 0.09678418 * t**3 - 0.18628806 * t**4 + 0.27886807 * t**5 - 1.13520398 * t**6 + 1.48851587 * t**7 - 0.82215223 * t**8 + 0.17087277 * t**9)
    erfx = 1 - tau
    return 1 - erfx

def inv_erfc(x):
    tolerance = 0.0000000001
    max_init = 10
    min_init = 0
    max_temp = max_init
    min_temp = min_init
    while max_temp - min_temp > tolerance:
        mid = (max_temp+min_temp)*0.5
        temp = erfc(mid)
        if x > temp:
            max_temp = mid
        else:
            min_temp = mid
    return mid


class parse_modylas:
    def __init__(self,fname):
        fp = open(fname,"rt")
        self.dict = self.getelem([l.strip() for l in fp])
        fp.close()
    def getelem(self,str_list):
        assigned = False
        blockname = ""
        inblock = False
        for l in str_list:
            re_block_begin = re.compile(r"^<([^/].*)>$").match(l)
            if re_block_begin and (not inblock):
                inblock = True
                contents = []
                blockname = re_block_begin.group(1)
            else:
                if l == "</"+blockname+">":
                    inblock = False
                    if not assigned:
                        out = {}
                        assigned = True
                    if blockname not in out:
                        out[blockname] = []
                    out[blockname] += [self.getelem(contents)]
                else:
                    if inblock:
                        contents.append(l)
                    else:
                        re_equal = re.compile(r"^(.*)=(.*)$").match(l)
                        if re_equal:
                            if not assigned:
                                out = {}
                                assigned = True
                            out[re_equal.group(1).strip()] = re_equal.group(2).strip()
                        else:
                            if not assigned:
                                out = []
                                assigned = True
                            out.append(re.split(r" +",l.strip()))
        if not assigned:
            out = []
        return out

if options.stdout == None:
    error("stdout file is not specified (try --help)")

if options.traj == None:
    error("trajectory file is not specified (try --help)")

check_exists("MDinfo")
check_exists("SltInfo")
check_exists(options.traj)
check_exists(options.stdout)
if options.rigid != None:
    check_exists(options.rigid)
if options.solute != None:
    check_exists(options.solute)
#    if os.path.splitext(options.solute)[1] != '.dcd':
#        error('only dcd format is supported.')
#if os.path.splitext(options.traj)[1] != '.dcd':
#    error('only dcd format is supported.')

if options.rigid != None and options.solute != None:
    error("Rigid insertion structure (--rigid) and flexible insertion structure (--solute) cannot be specified simultaneously")

if mode == "reference":
    if os.path.basename(os.getcwd()) != "refs":
        warn("The option is specified for insertion (reference system), but current directory name does not match")
else:
    # solution
    if os.path.basename(os.getcwd()) != "soln":
        warn("The option is specified for solution system, but current directory name does not match")

def save_parameters_fe(temp):
    feparamf = "../parameters_fe"
    fh = open(feparamf, "wt")
    print >> fh, "&fevars"
    print >> fh, "inptemp=%f" % temp
    print >> fh, "/"
    safe_close(fh)

def parse_log():
    dic = {}
    dic["temp"] = 300.0
    dic["boundary"] = "ppp"

    logfh = open(options.stdout, "rt")
    reading_params = False
    for l in logfh:
        if re.compile(r"^# *VERSION.*$").match(l):
            reading_params = True
        elif re.compile(r"^ *Modylas normally ended.*$").match(l):
            reading_params = False

        pos = l.find('#')
        if pos > -1:
            l = l[:pos]
            
        if reading_params:
            label = re.sub(r"^ *([^ ].*[^ ]) *:.*$",r"\1",l).strip()
            val = re.sub(r"\[.*\]",r"",re.sub(r"^.*: *([^ ].*) *$",r"\1",l).strip())
            if label == "MD_steps":
                dic["run"] = int(val)
            elif label == "dcd_interval":
                dic["dumpN"] = int(val)
#                if os.path.splitext(options.traj)[1] == '.dcd':
#                    dic["dumpN"] = int(val)
            elif label == "trj_interval":
                if re.compile(r"^.*bin").match(options.traj):
                    dic["dumpN"] = int(val)
            elif label == "ensemble":
                dic["ensemble"] = val.lower()
            elif label == "temperature":
                dic["temp"] = float(val)
            elif label == "LJ switch on":
                dic["cutoff_lj_in"] = float(val)
            elif label == "LJ switch off":
                dic["cutoff_lj_out"] = float(val)
            elif label == "LJ cutoff radius":
                dic["cutoff_coul"] = float(val)
            elif label == "Coulomb method":
                dic["kspace_style"] = val.lower()
            elif label == "bspline order":
                dic["pppm_order"] = int(val)
            elif label == "fftgridx":
                dic["meshx"] = int(val)
            elif label == "fftgridy":
                dic["meshy"] = int(val)
            elif label == "fftgridz":
                dic["meshz"] = int(val)
            elif label == "Ewald alpha":
                dic["gewald"] = float(val) * 1E-10
    logfh.close()

    if  dic["kspace_style"] == "fmm":
        warn("PME will be used in ermod instead of FMM.")
        if options.mdxyz == None:
            error("stdout file must be specified (try --help)")
        resol=1.0
        pme_error=1.e-5
        pbcdim = [int(float(x)/resol) for x in parse_modylas(options.mdxyz)['periodic cell'][0]['length'][0][0]]
        params['cltype']  = 2
        params['elecut'] = 12.0
        params['screen'] = inv_erfc(pme_error)/params['elecut']
        params['ms1max'] = pbcdim[0]
        params['ms2max'] = pbcdim[1]
        params['ms3max'] = pbcdim[2]
        params['splodr'] = 6
    elif dic["kspace_style"] == "pme":
        params['cltype']  = 2
        params['elecut'] = dic['cutoff_coul']
        params['screen'] = dic["gewald"]
        params['ms1max'] = dic["meshx"]
        params['ms2max'] = dic["meshy"]
        params['ms3max'] = dic["meshz"]
        params['splodr'] = dic["pppm_order"]
    else:
        error("Unsupported method for calculating coulomb potential")

    params["ljformat"] = 1
    params["cmbrule"]  = 0 # arithmetic
    params["inptemp"] = dic["temp"]
    params['ljswitch']  = 0

    if mode == "solution":
        save_parameters_fe(dic["temp"])

    if options.rigid:
        params['slttype'] = 2 # rigid
    elif options.solute:
        params['slttype'] = 3 # flexible
    else:
        params['slttype'] = 1 # solution

    if not dic.has_key("cutoff_lj_out"):
        dic["cutoff_lj_out"] = dic["cutoff_coul"]
    if not dic.has_key("cutoff_lj_in"):
        dic["cutoff_lj_in"] = dic["cutoff_coul"]
        
    params['upljcut'] = dic["cutoff_lj_out"]
    params['lwljcut'] = dic["cutoff_lj_in"]
        
    if dic["boundary"] == "ppp":
        params['boxshp'] = 1
        is_periodic = True
    elif dic["boundary"] == "fff":
        params['boxshp'] = 0
        is_periodic = False

    if dic["ensemble"] == "nvt":
        params['estype'] = 1
    elif dic["ensemble"] == "npt" or dic["ensemble"] == "npt_z" or dic["ensemble"] == "npt_a":
        params['estype'] = 2
    else:
        error("Unsupported ensemble type")

    if options.div == None:
        if mode == "reference":
            params["engdiv"] = 5
        else:
            params["engdiv"] = 10
    else:
        params["engdiv"] = options.div
    
    if options.maxins != None and mode == "reference":
        params["maxins"] = options.maxins

    # Order of the outputs to parameters_er
    output_var =["slttype", "sltspec", "boxshp", "estype", "inptemp",
                 "ljformat", "cmbrule", "ljswitch", "upljcut", "lwljcut",
                 "cltype", "elecut", "screen", "splodr",
                 "ms1max", "ms2max", "ms3max",
                 "maxins", "engdiv"]

    ofh = open("parameters_er", "wt")
    print >> ofh, "&ene_param"
    for k in output_var:
        if k in params.keys():
            v = params[k]
            if isinstance(v, str):
                print >> ofh, "        %s = \"%s\"," % (k, v)
            elif isinstance(v, int):
                print >> ofh, "        %s = %d," % (k, v)
            elif isinstance(v, float):
                print >> ofh, "        %s = %g," % (k, v)
            else:
                error("Unknown output type")
    
    print >> ofh, """/
&hist
      eclbin=5.0e-2, ecfbin=2.0e-3, ec0bin=2.0e-4, finfac=10.0e0,
      ecdmin=%f, ecfmns=-0.20e0, ecdcen=0.0e0, eccore=20.0e0,
      ecdmax=1.0e11, pecore=200
/
""" % options.minenergy

    if int(dic["dumpN"]) != 0:
        frames = int(dic["run"]) / int(dic["dumpN"]) + 1

    return (frames, is_periodic)
    
(frames, is_periodic) = parse_log()

# update MDinfo
if frames:
    ifh = open("MDinfo", "rt")
    ofh = open("MDinfo.new", "wt")
    l = ifh.next().split()
    print >> ofh, frames, l[1]
    print >> ofh, ifh.next().strip()
    print >> ofh, ifh.next().strip()
    ifh.close()
    safe_close(ofh)
    shutil.move("MDinfo", "MDinfo.bak")
    shutil.move("MDinfo.new", "MDinfo")

def symlink(src, dest):
    if os.path.exists(dest):
        if os.path.islink(dest):
            # renew link
            os.remove(dest)
        else:
            return
    os.symlink(src, dest)

# link or generate trajectory
(_, ext) = os.path.splitext(options.traj)
symlink(options.traj, "HISTORY")

if options.solute:
    # flexible
    symlink(options.solute, "SltConf")

elif options.rigid:
    def get_pdb_coord():
        # fixed
        fh = open(options.rigid, "rt")
        coords = []
        # overwrite SltInfo with coordinate information
        for l in fh:
            if l[0:4] == "ATOM" or l[0:6] == "HETATM":
                coords.append((float(l[30:38]), float(l[38:46]), float(l[46:54])))
        fh.close()
        return coords

    def get_mdxyz_coord():
        mdxyz = parse_modylas(options.rigid)
        coords = []
        for array in mdxyz.dict['atom'][0]['positions'][0]:
            coords.append([float(x) for x in array])
        return coords

    (_, ext) = os.path.splitext(options.rigid)
    if ext == ".pdb" or ext == ".PDB":
        coords = get_pdb_coord()
    else:
        coords = get_mdxyz_coord()
    
    ifh = open("SltInfo", "rt")
    ofh = open("SltInfo.new", "wt")
    pos = 0
    for l in ifh:
        print >> ofh, ' '.join((l.split())[0:5]), coords[pos][0], coords[pos][1], coords[pos][2]
        pos += 1

    ifh.close()
    safe_close(ofh)
    shutil.move("SltInfo", "SltInfo.bak")
    shutil.move("SltInfo.new", "SltInfo")

log('normally finished.')
