#!/usr/bin/env python3

import os
import os.path
import shutil
import sys
import re
import pickle
from argparse import ArgumentParser

parser = ArgumentParser()

parser.add_argument("-l", "--log", dest = "log",
                  help = "Log file generated by mdrun")

parser.add_argument("-x", "--traj", dest = "traj",
                  help = "Solution or reference trajectory file")

parser.add_argument("-r", "--rigid", dest = "rigid",
                  help = "Solute structure PDB / GRO file (rigid solute)")

parser.add_argument("-p", "--pdb", dest = "pdb",
                  help = "(Deprecated) solute structure PDB file (rigid solute)")
parser.add_argument("-g", "--gro", dest = "gro",
                  help = "(Deprecated) solute structure GRO file (rigid solute)")

parser.add_argument("-s", "--flexible", dest = "solute",
                  help = "Solute trajectory file (flexible solute)")

parser.add_argument("-d", "--div", dest = "div", type=int,
                  help = "Number of divided sections",
                  default = None)

parser.add_argument("--minenergy", dest = "minenergy", type=float,
                  help = "Minimum energy in kcal/mol",
                  default = -20.0)

parser.add_argument("--maxins", dest = "maxins", type=int,
                  help = "Number of insertions for refs (default: 1000)",
                  default = 1000)

parser.add_argument("-v", "--verbose", dest = "verbose", action = "store_true",
                  help = "Increase verbosity (for debug)",
                  default = False)

options = parser.parse_args()

mode = "solution"

if options.pdb:
    options.rigid = options.pdb

if options.gro:
    options.rigid = options.gro

if options.rigid != None or options.solute != None:
    mode = "reference"

params = {}
try:
    with open(".extraparam", "rb") as ifh:
        carryover = pickle.load(ifh)

    params["ljformat"] = {
        'C6C12': 4,
        'sigeps': 2,
        'table': 5
        }[carryover["ljformat"]]

    # gromacs-type switching function
    params["ljswitch"] = 1

    params["cmbrule"] = {
        'geometric': 1,
        'arithmetic': 0
        }[carryover["ljtype"]]

    if mode == "solution" and "sltspec" in carryover:
        params["sltspec"] = carryover["sltspec"]
    
except OSError:
    pass

def log(x):
    if options.verbose:
        print(x, file=sys.stderr)


def warn_or_error(x, col):
    prefix = ""
    suffix = ""
    if os.isatty(sys.stderr.fileno()):
        prefix = "\x1b[" + str(col) + ";1m"
        suffix = "\x1b[0m"
    print(prefix + x + suffix, file=sys.stderr)

def warn(x):
    warn_or_error("Warning: " + x, 33)

def error(x):
    warn_or_error("Error: " + x, 31)
    sys.exit(1)

if options.log == None:
    error("log file is not specified (try --help)")

if options.traj == None:
    error("trajectory file is not specified (try --help)")

def check_exists(f):
    if not os.path.exists(f):
        error("file " + f + " does not exist")

check_exists("MDinfo")
check_exists("SltInfo")
check_exists(options.traj)
check_exists(options.log)
if options.rigid != None:
    check_exists(options.rigid)

if options.solute != None:
    check_exists(options.solute)

if options.rigid != None and options.solute != None:
    error("Rigid insertion structure (--rigid) and flexible insertion structure (--flexible) cannot be specified simultaneously")

if mode == "reference":
    if os.path.basename(os.getcwd()) != "refs":
        warn("The option is specified for insertion (reference system), but current directory name does not match")
else:
    # solution
    if os.path.basename(os.getcwd()) != "soln":
        warn("The option is specified for solution system, but current directory name does not match")

def save_parameters_fe(temp):
    feparamf = "../parameters_fe"
    with open(feparamf, "wt") as fh:
        print("&fevars", file=fh)
        print("inptemp=%f" % temp, file=fh)
        print("/", file=fh)

# TODO: ljformat
# TODO: LJ table
def parse_mdp():
    with open(options.log, "rt") as logfh:
        pats = re.compile(r"^\s*([a-zA-Z0-9_\-]+)\s*=\s*(\S+)\s*$")
        reft = re.compile(r"^\s+ref[_-]t:\s+([0-9.]+)")
        beta = re.compile(r"Using a Gaussian width \(1/beta\) of (\S+) nm for Ewald")
        dic = {}
        temp = 300.0
        betawidth = None

        for l in logfh:
            pairs = pats.match(l)
            if pairs:
                # Replace by underscores, to handle both GROMACS pre-4.5 and post-4.6 series
                key = pairs.group(1).replace('-', '_')
                dic[key] = pairs.group(2)

            reftf = reft.match(l)
            if reftf:
                temp = float(reftf.group(1))

            betaf = beta.match(l)
            if betaf:
                betawidth = float(betaf.group(1))

    # From gromacs 5.0 following terms were renamed
    conversion = { 'vdw_type': 'vdwtype',
                   'pbc': 'ePBC',
                   'fourier_nx': 'nkx',
                   'fourier_ny': 'nky',
                   'fourier_nz': 'nkz',
                   'pcoupl': 'epc',
                   'nstxout_compressed': 'nstxtcout' }
    for k in list(dic.keys()):
        if k in conversion:
            dic[conversion[k]] = dic[k]

    if temp == 0.0:
        warn("Warning: failed to obtain correct input temperature. This may happen if you use more than one heat baths in the system or employ the NVE ensemble. Please manually correct parameters_er and paramters_fe.")
    params["inptemp"] = temp
    if mode == "solution":
        save_parameters_fe(temp)

    if options.rigid:
        params['slttype'] = 2 # rigid
    elif options.solute:
        params['slttype'] = 3 # flexible
    else:
        params['slttype'] = 1 # solution

    if dic["ePBC"] == "xyz":
        params['boxshp'] = 1
        is_periodic = True
    else:
        params['boxshp'] = 0
        is_periodic = False

    if dic["epc"] == "No":
        params['estype'] = 1
    elif dic["epc"] in ["Berendsen", "Parrinello-Rahman", "MTTK", "C-rescale"]:
        params['estype'] = 2
    else:
        warn("Warning: Unknown pressure coupling type (NVT assumed), check log / output")
        params['estype'] = 1

    modifier = dic.get("vdw_modifier", None)
    if dic["vdwtype"] == "Cut-off" and modifier in [None, "None", "Potential-shift", "Potential-shift-Verlet"]:
        cutoff = float(dic["rvdw"]) * 10.0 # nm -> angstrom
        params['upljcut'] = cutoff
        params['lwljcut'] = cutoff
    elif dic["vdwtype"] == "Switch" or modifier in ["Potential-switch", "Force-switch"]:
        params['upljcut'] = float(dic["rvdw"]) * 10.0
        params['lwljcut'] = float(dic["rvdw_switch"]) * 10.0
        params['ljswitch'] = 1 # GROMACS special potential-switch
        if modifier == "Force-switch":
            params['ljswitch'] = 3  # GROMACS special force-switch
    elif dic["vdwtype"] in ["Shift", "Encad-Shift"]:
        warn("shifted L-J potential is unsupported, and the abrupt cutoff is used instead (leading possibly to inconsistent result)")
        params['upljcut'] = float(dic["rvdw"]) * 10.0
        params['lwljcut'] = float(dic["rvdw_switch"]) * 10.0
    else:
        warn("unknown or unsupported vdwtype; you need to specify vdw parameters manually")

    if dic["coulombtype"]  == "Cut-off":
        params['cltype'] = 0
        cutoff = float(dic['rcoulomb']) * 10.0
        params['elecut'] = cutoff
    if dic["coulombtype"] == "Ewald":
        params['cltype'] = 1
        cutoff = float(dic['rcoulomb']) * 10.0
        params['elecut'] = cutoff
    if dic["coulombtype"] == "PME":
        params['cltype'] = 2
        cutoff = float(dic['rcoulomb']) * 10.0
        params['elecut'] = cutoff
        params['ms1max'] = int(dic['nkx'])
        params['ms2max'] = int(dic['nky'])
        params['ms3max'] = int(dic['nkz'])
        params['splodr'] = int(dic['pme_order'])
        params['screen'] = 1. / (betawidth * 10.0)
        
    if options.div == None:
        if mode == "reference":
            params["engdiv"] = 5
        else:
            params["engdiv"] = 10
    else:
        params["engdiv"] = options.div
    
    if options.maxins != None and mode == "reference":
        params["maxins"] = options.maxins

    # Order of the outputs to parameters_er
    output_var =["slttype", "sltspec", "boxshp", "estype", "inptemp",
                 "ljformat", "cmbrule", "ljswitch", "upljcut", "lwljcut",
                 "cltype", "elecut", "screen", "splodr",
                 "ms1max", "ms2max", "ms3max",
                 "maxins", "engdiv"]

    ofh = open("parameters_er", "wt")
    print("&ene_param", file=ofh)
    for k in output_var:
        if k in list(params.keys()):
            v = params[k]
            if isinstance(v, str):
                print("        %s = \"%s\"," % (k, v), file=ofh)
            elif isinstance(v, int):
                print("        %s = %d," % (k, v), file=ofh)
            elif isinstance(v, float):
                print("        %s = %g," % (k, v), file=ofh)
            else:
                error("Unknown output type")
    
    print("""/
&hist
      eclbin=5.0e-2, ecfbin=2.0e-3, ec0bin=2.0e-4, finfac=10.0e0,
      ecdmin=%f, ecfmns=-0.20e0, ecdcen=0.0e0, eccore=20.0e0,
      ecdmax=1.0e11, pecore=200
/
""" % options.minenergy, file=ofh)

    if int(dic["nstxtcout"]) != 0:
        frames = int(dic["nsteps"]) // int(dic["nstxtcout"])
    else:
        frames = int(dic["nsteps"]) // int(dic["nstxout"])
    return (frames, is_periodic)
    
(frames, is_periodic) = parse_mdp()

# update MDinfo
if frames:
    with open("MDinfo", "rt") as ifh, open("MDinfo.new", "wt") as ofh:
        l = next(ifh).split()
        print(frames, l[1], file=ofh)
        print(next(ifh).strip(), file=ofh)
        print(next(ifh).strip(), file=ofh)
    shutil.move("MDinfo", "MDinfo.bak")
    shutil.move("MDinfo.new", "MDinfo")

def symlink(src, dest):
    if os.path.exists(dest):
        if os.path.islink(dest):
            # renew link
            os.remove(dest)
        else:
            return
    os.symlink(src, dest)

# link or generate trajectory
(_, ext) = os.path.splitext(options.traj)
symlink(options.traj, "HISTORY")

if options.solute:
    # flexible
    symlink(options.solute, "SltConf")

elif options.rigid:
    def get_pdb_coord():
        # fixed
        fh = open(options.rigid, "rt")
        coords = []
        # overwrite SltInfo with coordinate information
        for l in fh:
            if l[0:4] == "ATOM" or l[0:6] == "HETATM":
                coords.append((float(l[30:38]), float(l[38:46]), float(l[46:54])))
        fh.close()
        return coords

    def get_gro_coord():
        coords = []
        with open(options.rigid, "rt") as fh:
            _l = next(fh) # header
            natoms = int(next(fh).strip())
            for _i in range(natoms):
                line = next(fh)
                x = float(line[20:28].strip())
                y = float(line[28:36].strip())
                z = float(line[36:44].strip())
                uc = 10.0 # nm to angstrom
                coords.append((x*uc, y*uc, z*uc))
        return coords

    (_, ext) = os.path.splitext(options.rigid)
    if ext == ".pdb" or ext == ".PDB":
        coords = get_pdb_coord()
    elif ext == ".gro":
        coords = get_gro_coord()
    else:
        error("Unknown rigid file extension")
    
    with open("SltInfo", "rt") as ifh, open("SltInfo.new", "wt") as ofh:
        for pos, l in enumerate(ifh):
            ls = l.split()
            if len(ls) in [5, 8]:
                # SltInfo generated by pre-1.0 gen_input
                raise RuntimeError("SltInfo format is old, please restart from gen_structure")
            print(' '.join(ls[0:7]), coords[pos][0], coords[pos][1], coords[pos][2], file=ofh)
    shutil.move("SltInfo", "SltInfo.bak")
    shutil.move("SltInfo.new", "SltInfo")
